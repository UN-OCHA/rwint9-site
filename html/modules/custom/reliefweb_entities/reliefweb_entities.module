<?php

/**
 * @file
 * Entity management for ReliefWeb.
 */

use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Entity\EntityFormInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\RevisionLogInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Render\Element;
use Drupal\media\MediaInterface;
use Drupal\reliefweb_entities\BundleEntityInterface;
use Drupal\reliefweb_entities\BundleEntityStorageInterface;
use Drupal\reliefweb_entities\EntityFormAlterServiceBase;
use Drupal\reliefweb_utility\Helpers\ClassHelper;
use Drupal\reliefweb_utility\Helpers\DateHelper;
use Drupal\reliefweb_utility\Helpers\EntityHelper;
use Drupal\reliefweb_utility\Helpers\MailHelper;
use Drupal\reliefweb_utility\Helpers\MediaHelper;
use Drupal\reliefweb_utility\Helpers\ReliefWebStateHelper;
use Drupal\reliefweb_utility\Helpers\TaxonomyHelper;
use Drupal\reliefweb_utility\Helpers\TextHelper;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_entity_base_field_info().
 *
 * Add a created field to taxonomy terms as Drupal Core is not yet doing that.
 *
 * @see https://www.drupal.org/project/drupal/issues/2869432
 */
function reliefweb_entities_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];

  switch ($entity_type->id()) {
    case 'taxonomy_term':
      $fields['created'] = reliefweb_entities_get_taxonomy_term_created_field_definition();
      break;
  }

  return $fields;
}

/**
 * Get the taxonomy term "created" field definition.
 *
 * @return \Drupal\Core\Field\BaseFieldDefinition
 *   Field definition.
 */
function reliefweb_entities_get_taxonomy_term_created_field_definition() {
  return BaseFieldDefinition::create('created')
    ->setLabel(t('Created'))
    ->setDescription(t('The time that the term was created.'))
    ->setReadOnly(TRUE)
    ->setTranslatable(TRUE);
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function reliefweb_entities_entity_bundle_field_info_alter(array &$fields, EntityTypeInterface $entity_type, $bundle) {
  $namespace = '\Drupal\reliefweb_entities\Entity';

  $class = ClassHelper::classExists($namespace, $bundle);
  if ($class === FALSE) {
    $class = ClassHelper::classExists($namespace, $entity_type->id() . 'Base');
  }
  if ($class !== FALSE && is_subclass_of($class, BundleEntityInterface::class)) {
    $class::addFieldConstraints($fields);
  }
}

/**
 * Implements hook_entity_bundle_info_alter().
 *
 * Add bundle classes to nodes and terms to handle business logic.
 */
function reliefweb_entities_entity_bundle_info_alter(&$bundles) {
  $namespace = '\Drupal\reliefweb_entities\Entity';

  foreach ($bundles as $entity_type_id => $items) {
    foreach ($items as $bundle => $info) {
      $class = ClassHelper::classExists($namespace, $bundle);
      if ($class === FALSE) {
        $class = ClassHelper::classExists($namespace, $entity_type_id . 'Base');
      }
      if ($class !== FALSE && is_subclass_of($class, BundleEntityInterface::class)) {
        $label = ucwords(str_replace(['_', '-'], ' ', $bundle));
        $bundles[$entity_type_id][$bundle]['class'] = $class;
        $bundles[$entity_type_id][$bundle]['label'] = $label;
      }
    }
  }
}

/**
 * Implements hook_entity_type_alter().
 *
 * Override content entity storages so we can add post transaction hooks.
 */
function reliefweb_entities_entity_type_alter(array &$entity_types) {
  $namespace = '\Drupal\reliefweb_entities';

  /** @var \Drupal\Core\Entity\EntityTypeInterface $entity_type */
  foreach ($entity_types as $entity_type_id => $entity_type) {
    $storage_class = $entity_type->getStorageClass();
    if (empty($storage_class)) {
      break;
    }

    $classname = ClassHelper::toCamelCase($entity_type_id);
    $class = ClassHelper::classExists($namespace, 'Bundle' . $classname . 'Storage');
    if ($class !== FALSE && is_subclass_of($class, $storage_class) && is_subclass_of($class, BundleEntityStorageInterface::class)) {
      $entity_type->setStorageClass($class);
    }
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 *
 * Add suggestions for the view mode of the taxonomy terms.
 */
function reliefweb_entities_theme_suggestions_taxonomy_term_alter(array &$suggestions, array $variables) {
  /** @var \Drupal\taxonomy\TermInterface $term */
  $term = $variables['elements']['#taxonomy_term'];

  if (!empty($variables['elements']['#view_mode'])) {
    $view_mode = $variables['elements']['#view_mode'];
    $suggestions[] = 'taxonomy_term__' . $view_mode;
    $suggestions[] = 'taxonomy_term__' . $term->bundle() . '__' . $view_mode;
  }
}

/**
 * Implements hook_theme().
 */
function reliefweb_entities_theme() {
  return [
    'reliefweb_entities_sectioned_content' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // This is the table of content which is a render array using the
        // reliefweb_entities_table_of_contents theme.
        'contents' => NULL,
        // This is a list of sections as render arrays.
        'sections' => NULL,
      ],
    ],
    'reliefweb_entities_table_of_contents' => [
      'variables' => [
        // Section headling level.
        'level' => 2,
        // Section id.
        'id' => 'table-of-contents',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Table of Content'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of sections grouped by category. Each category has a title and
        // a list of sub-sections which are an array keyed by ids (to use for
        // anchors) and with the sub-section titles are values.
        'sections' => [],
      ],
    ],
    'reliefweb_entities_entity_country_slug' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // List of countries with the a url to either the country page or the
        // river filtered by the country, a name and a shortname.
        'countries' => [],
      ],
    ],
    'reliefweb_entities_entity_meta' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // Flag indicating the list of meta is the "core" meta information,
        // usually displayed in river articles or below the title on article
        // pages.
        'core' => TRUE,
        // List of meta information for an article (ex: dates, sources etc.).
        // Each meta data has the following properties: type (simple, date,
        // date-range or taglist), label, value (simple, date, array with start
        // and end date or list of tags). For tag lists, there are also count
        // and sort properties.
        'meta' => [],
      ],
    ],
    'reliefweb_entities_entity_text' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => '',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => '',
        // Section title attributes.
        'title_attributes' => NULL,
        // The text content should be a safe HTML string.
        'content' => '',
        // Text content attributes.
        'content_attributes' => NULL,
        // Flag indicating if iframes are allowed in the rendered HTML content.
        'iframe' => TRUE,
        // List of extra attributes allowed in the rendered HTML content.
        'allowed_attributes' => [],
      ],
    ],
    'reliefweb_entities_entity_details' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'details',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Details'),
        // Section title attributes.
        'title_attributes' => NULL,
        // Core flag, see "reliefweb_entities_entity_meta" above.
        'core' => FALSE,
        // Meta information, see "reliefweb_entities_entity_meta" above.
        'meta' => '',
        // Meta information attributes.
        'meta_attributes' => NULL,
      ],
    ],
    'reliefweb_entities_entity_social_media_links' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'social-media',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Social Media'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of social media links with a url and title.
        'links' => [],
        // Flag to indicate that the links should be icons only.
        'icons_only' => FALSE,
      ],
    ],
    'reliefweb_entities_entity_useful_links' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'useful-links',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Useful Links'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of links.
        'links' => [],
      ],
    ],
    'reliefweb_entities_entity_source_disclaimers' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => NULL,
        // Section title attributes.
        'title_attributes' => NULL,
        // List of source disclaimers. Each item has those properties:
        // - name: source name
        // - disclaimer: source disclaimer.
        'disclaimers' => [],
      ],
    ],
    'reliefweb_entities_entity_image' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // Image style.
        'style' => NULL,
        // Image information with uri, width, height, alt and copyright
        // and optionally the loading mode.
        'image' => [],
        // Flag to indicate whether to show the caption or not.
        'caption' => TRUE,
        // Flag to indicate the default loading mode: lazy or eager.
        'loading' => 'lazy',
      ],
    ],
    'reliefweb_entities_book_menu' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Book navigation'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of menu links with a url, title and optional "below" property
        // that contains child links.
        'links' => [],
      ],
    ],
    'reliefweb_entities_form_user_information' => [
      'variables' => [
        // Section attributes.
        'attributes' => NULL,
        // Entity information with type, url, id and creation date.
        'entity' => NULL,
        // Entity author information with name, mail and url.
        'author' => NULL,
        // Source information with author rights for the sources. Each element
        // has a URL to the source and the right information with id and label.
        'sources' => NULL,
        // Potential new source information with the name, url and right with
        // id and label.
        'new_source' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_token_info().
 *
 * Add content type token that returns "map" if the node is tagged with "Map".
 */
function reliefweb_entities_token_info() {
  $info = [];

  $info['tokens']['node']['reliefweb-content-type'] = [
    'name' => t('ReliefWeb - custom content type'),
    'description' => t('The unique machine-readable content type or map or infographic.'),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 *
 * @todo add token for the country shortname to use in report/job/training urls.
 */
function reliefweb_entities_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'reliefweb-content-type':
          // Use the bundle as content type.
          $replacements[$original] = $node->bundle();
          // Use "map" as content type for maps.
          if ($node->bundle() === 'report') {
            $content_format = $node->field_content_format->entity;
            if (!empty($content_format) && $content_format->label() === 'Map') {
              $replacements[$original] = 'map';
            }
          }
          break;
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_HOOK_alter() for "node_form".
 */
function reliefweb_entities_form_node_form_alter(array &$form, FormStateInterface $form_state) {
  EntityFormAlterServiceBase::alterEntityForm($form, $form_state);
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_term_form".
 */
function reliefweb_entities_form_taxonomy_term_form_alter(array &$form, FormStateInterface $form_state) {
  EntityFormAlterServiceBase::alterEntityForm($form, $form_state);

  // Empty the revision log message as we always create new revisions.
  //
  // @see reliefweb_entities_set_taxonomy_term_revision()
  if (!empty($form['revision_log_message']['widget'][0]['value']['#default_value'])) {
    $form['revision_log_message']['widget'][0]['value']['#default_value'] = '';
  }

  // Force revisions.
  if (!isset($form['revision'])) {
    $form['revision'] = [
      '#type' => 'checkbox',
      '#title' => t('Create new revision'),
      '#access' => FALSE,
    ];
  }
  $form['revision']['#default_value'] = TRUE;

  // Add an entity builder callback that will ensure the proper revisio
  // user id and timestamp are set.
  $form['#entity_builders'][] = 'reliefweb_entities_term_form_entity_builder';
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_overview_vocabularies".
 */
function reliefweb_entities_form_taxonomy_overview_vocabularies_alter(array &$form, FormStateInterface $form_state) {
  // Prevent re-ordering the vocabularies without the appropriate permission.
  if (!\Drupal::currentUser()->hasPermission('administer taxonomy')) {
    $form['actions']['#access'] = FALSE;
    unset($form['vocabularies']['#tabledrag']);
    unset($form['vocabularies']['#header']['weight']);
    foreach (Element::children($form['vocabularies']) as $key) {
      unset($form['vocabularies'][$key]['weight']);
    }
  }
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_overview_terms".
 */
function reliefweb_entities_form_taxonomy_overview_terms_alter(array &$form, FormStateInterface $form_state) {
  // Prevent re-ordering the terms without the appropriate permission.
  if (!\Drupal::currentUser()->hasPermission('administer taxonomy')) {
    $form['actions']['#access'] = FALSE;
    $form['help']['#access'] = FALSE;
    unset($form['terms']['#tabledrag']);
    unset($form['terms']['#header']['weight']);
    foreach (Element::children($form['terms']) as $key) {
      unset($form['terms'][$key]['weight']);
    }
  }
}

/**
 * Form entity builder callback.
 *
 * We emulate the logic to set the revision user and timestamp from
 * \Drupal\Core\Entity\ContentEntityForm::buildEntity() for taxonomy terms
 * because there is no easy way to have the taxonomy term entity type
 * `showRevisionUi()` method return TRUE...
 *
 * @param string $entity_type_id
 *   Entity type ID.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Term entity.
 * @param array $form
 *   The term form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function reliefweb_entities_term_form_entity_builder($entity_type_id, EntityInterface $entity, array &$form, FormStateInterface $form_state) {
  if ($entity instanceof RevisionLogInterface && !$form_state->isValueEmpty('revision')) {
    // Set the current user as the revision user if a new revision is requested.
    $entity->setRevisionUserId(\Drupal::currentUser()->id());
    $entity->setRevisionCreationTime(\Drupal::time()->getRequestTime());
  }
}

/**
 * Implements hook_form_alter().
 */
function reliefweb_entities_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  // Prevent deletion of taxonomy term referenced by other entities.
  $form_object = $form_state->getFormObject();
  if ($form_object instanceof EntityFormInterface && $form_object->getOperation() === 'delete') {
    $entity = $form_state->getFormObject()->getEntity();
    if (isset($entity) && $entity instanceof TermInterface && $entity->id() !== NULL) {
      if (TaxonomyHelper::isTermReferenced($entity)) {
        $form['actions']['submit']['#access'] = FALSE;
        $form['description']['#markup'] = t('The term CANNOT be deleted because there is content (reports, jobs, training etc.) tagged with it.');
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function reliefweb_entities_module_implements_alter(array &$implementation, $hook) {
  // Remove the hook_entity_presave() implementation from the
  // taxonomy_term_revision module because it doesn't allow us to speify the
  // revision user or timestamp. This is replaced by
  // reliefweb_entities_set_taxonomy_term_revision().
  //
  // @see taxonomy_term_revision_entity_presave()
  // @see reliefweb_entities_set_taxonomy_term_revision()
  if ($hook === 'entity_presave') {
    unset($implementation['taxonomy_term_revision']);
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function reliefweb_entities_theme_registry_alter(array &$theme_registry) {
  // Remove the hook_preprocess_media() implementation from the media_library
  // because it's not compatible with the inline entity form as it tries to
  // create a link to the media while it may not yet have an ID (temporary
  // media entity when creating a new content). This is replaced by
  // reliefweb_entities_preprocess_media().
  //
  // @see media_library_preprocess_media()
  // @see reliefweb_entities_preprocess_media()
  foreach ($theme_registry as $theme => $info) {
    if (isset($info['preprocess functions'])) {
      foreach ($info['preprocess functions'] as $key => $value) {
        if ($value === 'media_library_preprocess_media') {
          unset($theme_registry[$theme]['preprocess functions'][$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_media().
 *
 * Replacement of media_library_preprocess_media() that is compatible with
 * inline_entity_form which can create temporary media which don't yet have
 * an ID and so cannot have a URL.
 *
 * @see media_library_preprocess_media()
 */
function reliefweb_entities_preprocess_media(array &$variables) {
  if ($variables['view_mode'] === 'media_library') {
    /** @var \Drupal\media\MediaInterface $media */
    $media = $variables['media'];
    $variables['#cache']['contexts'][] = 'user.permissions';
    if ($media->id() !== NULL) {
      $rel = $media->access('edit') ? 'edit-form' : 'canonical';
      $variables['url'] = $media->toUrl($rel, [
        'language' => $media->language(),
      ]);
    }
    $variables += [
      'preview_attributes' => new Attribute(),
      'metadata_attributes' => new Attribute(),
    ];
    $variables['status'] = $media->isPublished();
  }
}

/**
 * Implements hook_entity_presave().
 */
function reliefweb_entities_entity_presave(EntityInterface $entity) {
  // Remove control characters from an entity's text fields.
  reliefweb_entities_clean_text_fields($entity);

  // Set the taxonomy term revision.
  reliefweb_entities_set_taxonomy_term_revision($entity);
}

/**
 * Set a taxonomy term's revision information.
 *
 * Note: this replaces the taxonomy_term_revision_entity_presave() which
 * is not flexible and forces the revision user ID and creation time.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 *
 * @see taxonomy_term_revision_entity_presave()
 */
function reliefweb_entities_set_taxonomy_term_revision(EntityInterface $entity) {
  // Saving new revision of term on each save.
  if ($entity instanceof TermInterface) {
    $entity->setNewRevision(TRUE);
    if (is_null($entity->getRevisionUserId())) {
      $entity->setRevisionUserId(\Drupal::currentUser()->id());
    }
    if (empty($entity->getRevisionCreationTime())) {
      $entity->setRevisionCreationTime(\Drupal::time()->getRequestTime());
    }
  }
}

/**
 * Remove control characters from an entity's text fields.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 */
function reliefweb_entities_clean_text_fields(EntityInterface $entity) {
  $entity_type_id = $entity->getEntityTypeId();
  if ($entity_type_id === 'node' || $entity_type_id === 'taxonomy_term') {
    $field_definitions = \Drupal::service('entity_field.manager')
      ->getFieldDefinitions($entity_type_id, $entity->bundle());

    $text_field_types = [
      'text',
      'text_long',
      'text_with_summary',
      'string',
      'string_long',
    ];
    $columns = [
      'value',
      'summary',
    ];
    $options = [
      'title' => ['line_breaks' => TRUE, 'consecutive' => TRUE],
      'name' => ['line_breaks' => TRUE, 'consecutive' => TRUE],
    ];

    // Clean the text fields.
    foreach ($field_definitions as $field => $definition) {
      if ($entity->hasField($field) && in_array($definition->getType(), $text_field_types)) {
        foreach ($entity->get($field) as $item) {
          foreach ($columns as $column) {
            if (isset($item->{$column})) {
              $value = $item->get($column)->getValue();
              $item->set($column, TextHelper::cleanText($value, $options[$field] ?? []));
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_mail().
 *
 * Populate the subject and body of the message sent after publishing a report.
 */
function reliefweb_entities_mail($key, array &$message, array $parameters) {
  if ($key === 'report_publication_notification') {
    $message['subject'] = $parameters['subject'];
    $message['body'][] = $parameters['content'];
    // Plain text only.
    $message['params']['plaintext'] = MailHelper::getPlainText($message['body']);
    $message['params']['plain'] = TRUE;
    // Use the submit mailbox as sender and add it also as CC to track the
    // notifications.
    $submit = ReliefWebStateHelper::getSubmitEmail();
    if (!empty($submit)) {
      $message['headers']['From'] = $submit;
      $message['headers']['CC'] = $submit;
    }
  }
}

/**
 * Implements hook_cron().
 *
 * This performs the following tasks:
 * - Publish embargoed documents.
 * - Expire jobs and training.
 *
 * At max 20 nodes of each type is processed at once to avoid clogging the cron
 * process and using excessive resources.
 */
function reliefweb_entities_cron() {
  $storage = \Drupal::entityTypeManager()->getStorage('node');
  $cron_settings = \Drupal::config('reliefweb_entities.settings')->get('cron') ?? [];

  // Publish embargoed reports.
  $embargoed_ids = $storage
    ->getQuery()
    ->condition('type', 'report', '=')
    ->condition('field_embargo_date.value', gmdate("Y-m-d\TH:i:s"), '<')
    ->range(0, $cron_settings['embargoed_reports_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  if (!empty($embargoed_ids)) {
    $reports = $storage->loadMultiple($embargoed_ids) ?? [];
    foreach ($reports as $report) {
      $timestamp = DateHelper::getDateTimeStamp($report->field_embargo_date->value);
      $report->setCreatedTime($timestamp);
      $report->setModerationStatus('published');
      $report->field_embargo_date->setValue([]);
      $report->setNewRevision(TRUE);
      $report->setRevisionUserId(2);
      $report->setRevisionLogMessage(strtr('Embargoed document automatically published on @date.', [
        '@date' => DateHelper::format($timestamp, 'custom', 'd M Y H:i e'),
      ]));
      $report->save();
    }
  }

  // Change status of expired jobs and training.
  $expired_ids = [];
  $time = gmmktime(0, 0, 0);
  $date = gmdate("Y-m-d", $time);

  $expired_ids += $storage
    ->getQuery()
    ->condition('type', 'job', '=')
    ->condition('moderation_status', 'published', '=')
    ->condition('field_job_closing_date.value', $date, '<')
    ->range(0, $cron_settings['expired_jobs_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  $expired_ids += $storage
    ->getQuery()
    ->condition('type', 'training', '=')
    ->condition('moderation_status', 'published', '=')
    ->condition('field_registration_deadline.value', $date, '<')
    ->range(0, $cron_settings['expired_training_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  if (!empty($expired_ids)) {
    $nodes = $storage->loadMultiple($expired_ids) ?? [];
    foreach ($nodes as $node) {
      $node->setModerationStatus('expired');
      $node->setNewRevision(TRUE);
      $node->setRevisionUserId(2);
      $node->setRevisionLogMessage(strtr('@type automatically expired on @date.', [
        '@type' => ucfirst($node->bundle()),
        '@date' => DateHelper::format($time, 'custom', 'd M Y H:i e'),
      ]));
      $node->save();
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function reliefweb_entities_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  // Open the clone entity form in a new tab.
  if (isset($data['tabs'][0]['content_entity_clone.clone']['#link'])) {
    $data['tabs'][0]['content_entity_clone.clone']['#link']['localized_options']['attributes']['target'] = '_blank';
  }
}

/**
 * Implements hook_preprocess_page__404().
 *
 * Add a user friendly message on inaccessible entity pages to indicate it's
 * no longer available (we assume the URL was previously accessible, which is
 * probably true in most cases).
 */
function reliefweb_entities_preprocess_page__404(array &$variables) {
  // Get the entity from the original request.
  $entity = EntityHelper::getEntityFromRequest(\Drupal::requestStack()->getMainRequest());
  if (isset($entity) && $entity instanceof BundleEntityInterface) {
    $type = mb_strtolower(EntityHelper::getBundleLabelFromEntity($entity));
    $title = $entity->label();

    $message = t('The @type %title is no longer available.', [
      '@type' => $type,
      '%title' => $title,
    ]);

    $variables['page']['content']['message'] = [
      '#type' => 'markup',
      '#markup' => $message,
    ];
  }

  // We need to vary the cache whether or not we are on an entity page
  // otherwise visiting a non entity inaccessible page will cache the result
  // and this preprocess hook implementation will not be called when visiting
  // an inaccessible entity page afterwards.
  $variables['#cache']['contexts'][] = 'url.path';
}

/**
 * Implements hook_ENTITY_TYPE_delete() for 'media'.
 *
 * Remove the source file when deleting a media.
 */
function reliefweb_entities_media_delete(MediaInterface $media) {
  $file = MediaHelper::getMediaSourceFile($media);
  // Delete the source file if not used anywhere else.
  if (!empty($file) && empty(\Drupal::service('file.usage')->listUsage($file))) {
    $file->setTemporary();
    $file->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for 'node'.
 *
 * Retrieve the list of referenced media Ids across all revisions before
 * deleting the entity.
 */
function reliefweb_entities_node_predelete(EntityInterface $entity) {
  // Only the image field for announcements and reports do not allow re-using
  // existing media.
  if (in_array($entity->bundle(), ['announcement', 'report'])) {
    // Get the list of referenced media Ids. We need to do that before the
    // entity is actually deleted.
    $entity->_referencedMediaIds = \Drupal::database()
      ->select('node_revision__field_image', 'f')
      ->fields('f', ['field_image_target_id'])
      ->condition('f.entity_id', $entity->id(), '=')
      ->distinct()
      ->execute()
      ?->fetchCol() ?? [];
  }
}

/**
 * Implements hook_ENTITY_TYPE_revision_delete().
 *
 * Remove referenced media that are not used anymore.
 */
function reliefweb_entities_node_delete(EntityInterface $entity) {
  // Only the image field for announcements and reports do not allow re-using
  // existing media.
  if (in_array($entity->bundle(), ['announcement', 'report'])) {
    // Delete referenced media entities.
    if (!empty($entity->_referencedMediaIds)) {
      $media_entities = \Drupal::entityTypeManager()
        ->getStorage('media')
        ->loadMultiple($entity->_referencedMediaIds);

      foreach ($media_entities as $media) {
        $media->delete();
      }
    }
  }
}
