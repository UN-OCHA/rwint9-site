<?php

/**
 * @file
 * Entity management for ReliefWeb.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Entity\EntityFormInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityPublishedInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\RevisionLogInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Render\Element;
use Drupal\Core\Url;
use Drupal\media\MediaInterface;
use Drupal\ocha_content_classification\Entity\ClassificationWorkflowInterface;
use Drupal\ocha_content_classification\Enum\ClassificationStatus;
use Drupal\pathauto\PathautoState;
use Drupal\reliefweb_entities\BundleEntityInterface;
use Drupal\reliefweb_entities\BundleEntityStorageInterface;
use Drupal\reliefweb_entities\EntityFormAlterServiceBase;
use Drupal\reliefweb_moderation\EntityModeratedInterface;
use Drupal\reliefweb_utility\Helpers\ClassHelper;
use Drupal\reliefweb_utility\Helpers\DateHelper;
use Drupal\reliefweb_utility\Helpers\MailHelper;
use Drupal\reliefweb_utility\Helpers\MediaHelper;
use Drupal\reliefweb_utility\Helpers\ReliefWebStateHelper;
use Drupal\reliefweb_utility\Helpers\TaxonomyHelper;
use Drupal\reliefweb_utility\Helpers\TextHelper;
use Drupal\taxonomy\TermInterface;
use Drupal\user\EntityOwnerInterface;
use Symfony\Component\HttpKernel\Exception\GoneHttpException;

/**
 * Implements hook_entity_base_field_info().
 *
 * Add a created field to taxonomy terms as Drupal Core is not yet doing that.
 *
 * @see https://www.drupal.org/project/drupal/issues/2869432
 */
function reliefweb_entities_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];

  switch ($entity_type->id()) {
    case 'taxonomy_term':
      $fields['created'] = reliefweb_entities_get_taxonomy_term_created_field_definition();
      break;
  }

  return $fields;
}

/**
 * Get the taxonomy term "created" field definition.
 *
 * @return \Drupal\Core\Field\BaseFieldDefinition
 *   Field definition.
 */
function reliefweb_entities_get_taxonomy_term_created_field_definition() {
  return BaseFieldDefinition::create('created')
    ->setLabel(t('Created'))
    ->setDescription(t('The time that the term was created.'))
    ->setReadOnly(TRUE)
    ->setTranslatable(TRUE);
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function reliefweb_entities_entity_bundle_field_info_alter(array &$fields, EntityTypeInterface $entity_type, $bundle) {
  $namespace = '\Drupal\reliefweb_entities\Entity';

  $class = ClassHelper::classExists($namespace, $bundle);
  if ($class === FALSE) {
    $class = ClassHelper::classExists($namespace, $entity_type->id() . 'Base');
  }
  if ($class !== FALSE && is_subclass_of($class, BundleEntityInterface::class)) {
    $class::addFieldConstraints($fields);
  }
}

/**
 * Implements hook_entity_bundle_info_alter().
 *
 * Add bundle classes to nodes and terms to handle business logic.
 */
function reliefweb_entities_entity_bundle_info_alter(&$bundles) {
  $namespace = 'Drupal\reliefweb_entities\Entity';

  foreach ($bundles as $entity_type_id => $items) {
    foreach ($items as $bundle => $info) {
      $class = ClassHelper::classExists($namespace, $bundle);
      if ($class === FALSE) {
        $class = ClassHelper::classExists($namespace, $entity_type_id . 'Base');
      }
      if ($class !== FALSE && is_subclass_of($class, BundleEntityInterface::class)) {
        $label = ucwords(str_replace(['_', '-'], ' ', $bundle));
        // No leading \ otherwise EntityTypeRepository::getEntityTypeFromClass
        // fails.
        $bundles[$entity_type_id][$bundle]['class'] = $class;
        $bundles[$entity_type_id][$bundle]['label'] = $label;
      }
    }
  }
}

/**
 * Implements hook_entity_type_alter().
 *
 * Override content entity storages so we can add post transaction hooks.
 */
function reliefweb_entities_entity_type_alter(array &$entity_types) {
  $namespace = '\Drupal\reliefweb_entities';

  /** @var \Drupal\Core\Entity\EntityTypeInterface $entity_type */
  foreach ($entity_types as $entity_type_id => $entity_type) {
    $storage_class = $entity_type->getStorageClass();
    if (empty($storage_class)) {
      break;
    }

    $classname = ClassHelper::toCamelCase($entity_type_id);
    $class = ClassHelper::classExists($namespace, 'Bundle' . $classname . 'Storage');
    if ($class !== FALSE && is_subclass_of($class, $storage_class) && is_subclass_of($class, BundleEntityStorageInterface::class)) {
      $entity_type->setStorageClass($class);
    }
  }
}

/**
 * Implements hook_entity_form_mode_alter().
 *
 * Set the form view mode for the submitters.
 */
function reliefweb_entities_entity_form_mode_alter(string &$form_mode, EntityInterface $entity): void {
  // Set the report form mode depending on the user role.
  if ($entity->getEntityTypeId() === 'node' && $entity->bundle() === 'report') {
    $user = \Drupal::currentUser();
    // @todo also create a form mode for the contributor role.
    if ($user->hasRole('submitter') && !$user->hasRole('contributor') && !$user->hasRole('editor')) {
      $form_mode = 'submitter';
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function reliefweb_entities_entity_insert(EntityInterface $entity): void {
  reliefweb_entities_create_path_alias($entity);
}

/**
 * Implements hook_entity_update().
 */
function reliefweb_entities_entity_update(EntityInterface $entity): void {
  reliefweb_entities_create_path_alias($entity);
}

/**
 * Create a path alias when publishing an entity if it doesn't have one.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity for which to create an alias.
 */
function reliefweb_entities_create_path_alias(EntityInterface $entity): void {
  // Skip for entities we don't manage in this module or cannot have a path.
  if (!($entity instanceof BundleEntityInterface) || !$entity->hasField('path')) {
    return;
  }
  // Skip if the entity is not published.
  if (!($entity instanceof EntityPublishedInterface) || !$entity->isPublished()) {
    return;
  }
  // Tell pathauto to create an alias if there is none.
  if (empty($entity->path->pid)) {
    $entity->path->pathauto = PathautoState::CREATE;
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function reliefweb_entities_module_implements_alter(&$implementations, $hook) {
  // Ensure we run before pathauto so that we can set `$entity->path->pathauto`.
  if (in_array($hook, ['entity_insert', 'entity_update']) && isset($implementations['reliefweb_entities'], $implementations['pathauto'])) {
    $reliefweb_entities_implementation = $implementations['reliefweb_entities'];
    unset($implementations['reliefweb_entities']);

    $new_implementations = [];
    foreach ($implementations as $module => $implementation) {
      if ($module === 'pathauto') {
        $new_implementations['reliefweb_entities'] = $reliefweb_entities_implementation;
      }
      $new_implementations[$module] = $implementation;
    }

    $implementations = $new_implementations;
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 *
 * Add suggestions for the view mode of the taxonomy terms.
 */
function reliefweb_entities_theme_suggestions_taxonomy_term_alter(array &$suggestions, array $variables) {
  /** @var \Drupal\taxonomy\TermInterface $term */
  $term = $variables['elements']['#taxonomy_term'];

  if (!empty($variables['elements']['#view_mode'])) {
    $view_mode = $variables['elements']['#view_mode'];
    $suggestions[] = 'taxonomy_term__' . $view_mode;
    $suggestions[] = 'taxonomy_term__' . $term->bundle() . '__' . $view_mode;
  }
}

/**
 * Implements hook_theme().
 */
function reliefweb_entities_theme() {
  return [
    'reliefweb_entities_sectioned_content' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // This is the table of content which is a render array using the
        // reliefweb_entities_table_of_contents theme.
        'contents' => NULL,
        // This is a list of sections as render arrays.
        'sections' => NULL,
      ],
    ],
    'reliefweb_entities_table_of_contents' => [
      'variables' => [
        // Section headling level.
        'level' => 2,
        // Section id.
        'id' => 'table-of-contents',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Table of Content'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of sections grouped by category. Each category has a title and
        // a list of sub-sections which are an array keyed by ids (to use for
        // anchors) and with the sub-section titles are values.
        'sections' => [],
      ],
    ],
    'reliefweb_entities_entity_country_slug' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // List of countries with the a url to either the country page or the
        // river filtered by the country, a name and a shortname.
        'countries' => [],
      ],
    ],
    'reliefweb_entities_entity_meta' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // Flag indicating the list of meta is the "core" meta information,
        // usually displayed in river articles or below the title on article
        // pages.
        'core' => TRUE,
        // List of meta information for an article (ex: dates, sources etc.).
        // Each meta data has the following properties: type (simple, date,
        // date-range or taglist), label, value (simple, date, array with start
        // and end date or list of tags). For tag lists, there are also count
        // and sort properties.
        'meta' => [],
        // The entity.
        'entity' => NULL,
      ],
    ],
    'reliefweb_entities_entity_text' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => '',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => '',
        // Section title attributes.
        'title_attributes' => NULL,
        // The text content should be a safe HTML string.
        'content' => '',
        // Text content attributes.
        'content_attributes' => NULL,
        // Flag indicating if iframes are allowed in the rendered HTML content.
        'iframe' => TRUE,
        // List of extra attributes allowed in the rendered HTML content.
        'allowed_attributes' => [],
      ],
    ],
    'reliefweb_entities_entity_details' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'details',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Details'),
        // Section title attributes.
        'title_attributes' => NULL,
        // Core flag, see "reliefweb_entities_entity_meta" above.
        'core' => FALSE,
        // Meta information, see "reliefweb_entities_entity_meta" above.
        'meta' => '',
        // Meta information attributes.
        'meta_attributes' => NULL,
        // The entity.
        'entity' => NULL,
      ],
    ],
    'reliefweb_entities_entity_social_media_links' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'social-media',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Social Media'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of social media links with a url and title.
        'links' => [],
        // Flag to indicate that the links should be icons only.
        'icons_only' => FALSE,
      ],
    ],
    'reliefweb_entities_entity_useful_links' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section id.
        'id' => 'useful-links',
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Useful Links'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of links.
        'links' => [],
      ],
    ],
    'reliefweb_entities_entity_source_disclaimers' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => NULL,
        // Section title attributes.
        'title_attributes' => NULL,
        // List of source disclaimers. Each item has those properties:
        // - name: source name
        // - disclaimer: source disclaimer.
        'disclaimers' => [],
      ],
    ],
    'reliefweb_entities_entity_image' => [
      'variables' => [
        // Wrapper attributes.
        'attributes' => NULL,
        // Image style.
        'style' => NULL,
        // Image information with uri, width, height, alt and copyright
        // and optionally the loading mode.
        'image' => [],
        // Flag to indicate whether to show the caption or not.
        'caption' => TRUE,
        // Flag to indicate the default loading mode: lazy or eager.
        'loading' => 'lazy',
      ],
    ],
    'reliefweb_entities_book_menu' => [
      'variables' => [
        // Section heading level.
        'level' => 2,
        // Section attributes.
        'attributes' => NULL,
        // Section title.
        'title' => t('Book navigation'),
        // Section title attributes.
        'title_attributes' => NULL,
        // List of menu links with a url, title and optional "below" property
        // that contains child links.
        'links' => [],
      ],
    ],
    'reliefweb_entities_form_user_information' => [
      'variables' => [
        // Section attributes.
        'attributes' => NULL,
        // Entity information with type, url, id and creation date.
        'entity' => NULL,
        // Entity author information with name, mail and url.
        'author' => NULL,
        // Source information with author rights for the sources. Each element
        // has a URL to the source and the right information with id and label.
        'sources' => NULL,
        // Potential new source information with the name, url and right with
        // id and label.
        'new_source' => NULL,
      ],
    ],
    'reliefweb_entities_entity_share_link' => [
      'variables' => [
        // Container attributes.
        'attributes' => NULL,
        // Label.
        'label' => NULL,
        // Entity URL.
        'url' => NULL,
        // Button attributes.
        'button_attributes' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_token_info().
 *
 * Add content type token that returns "map" if the node is tagged with "Map".
 */
function reliefweb_entities_token_info() {
  $info = [];

  $info['tokens']['node']['reliefweb-content-type'] = [
    'name' => t('ReliefWeb - custom content type'),
    'description' => t('The unique machine-readable content type or map or infographic.'),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 *
 * @todo add token for the country shortname to use in report/job/training urls.
 */
function reliefweb_entities_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'reliefweb-content-type':
          // Use the bundle as content type.
          $replacements[$original] = $node->bundle();
          // Use "map" as content type for maps.
          if ($node->bundle() === 'report') {
            $content_format = $node->field_content_format->entity;
            if (!empty($content_format) && $content_format->label() === 'Map') {
              $replacements[$original] = 'map';
            }
          }
          break;
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_HOOK_alter() for "node_form".
 */
function reliefweb_entities_form_node_form_alter(array &$form, FormStateInterface $form_state) {
  EntityFormAlterServiceBase::alterEntityForm($form, $form_state);

  foreach (Element::children($form['actions']) as $key) {
    if (isset($form['actions'][$key]['#submit'])) {
      $form['actions'][$key]['#submit'][] = 'reliefweb_entities_change_submit_message';
    }
  }
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_term_form".
 */
function reliefweb_entities_form_taxonomy_term_form_alter(array &$form, FormStateInterface $form_state) {
  EntityFormAlterServiceBase::alterEntityForm($form, $form_state);

  // Empty the revision log message as we always create new revisions.
  //
  // @see reliefweb_entities_set_taxonomy_term_revision()
  if (!empty($form['revision_log_message']['widget'][0]['value']['#default_value'])) {
    $form['revision_log_message']['widget'][0]['value']['#default_value'] = '';
  }

  // Force revisions.
  if (!isset($form['revision'])) {
    $form['revision'] = [
      '#type' => 'checkbox',
      '#title' => t('Create new revision'),
      '#access' => FALSE,
    ];
  }
  $form['revision']['#default_value'] = TRUE;

  // Add an entity builder callback that will ensure the proper revision
  // user id and timestamp are set.
  $form['#entity_builders'][] = 'reliefweb_entities_term_form_entity_builder';
}

/**
 * Change the message when submitting an entity.
 *
 * @param array $form
 *   The form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function reliefweb_entities_change_submit_message(array $form, FormStateInterface $form_state): void {
  $entity = $form_state->getFormObject()->getEntity();

  // Only for nodes currently.
  if ($entity->getEntityTypeId() !== 'node') {
    return;
  }

  $messenger = \Drupal::messenger();

  // Get all current status messages.
  $messages = $messenger->messagesByType('status');
  if (empty($messages)) {
    return;
  }

  $message_args = [
    '@type' => node_get_type_label($entity),
    '%title' => $entity->toLink()->toString(),
  ];

  // Existing possible creation/update message.
  // @see \Drupal\node\NodeForm::save()
  $created_message = (string) t('@type %title has been created.', $message_args);
  $updated_message = (string) t('@type %title has been updated.', $message_args);

  // Search for the update message and replace it.
  $found_update_message = FALSE;
  foreach ($messages as $key => $message) {
    $message = (string) $message;
    if ($message === $created_message || $message === $updated_message) {
      // Get the publication status from the current and previous revisions.
      $statuses = \Drupal::database()
        ->select('node_field_revision', 'nfr')
        ->fields('nfr', ['status'])
        ->condition('nfr.nid', $entity->id())
        ->orderBy('nfr.vid', 'DESC')
        ->range(0, 2)
        ->execute()
        ?->fetchCol() ?? [];

      // Convert to integers so we can properly match the values.
      $statuses = array_map(fn($status) => (int) $status, $statuses);

      // Replace the message based on the publication status.
      $status_message = match($statuses) {
        [0] => t('@type %title has been created but is not yet published.', $message_args),
        [1] => t('@type %title has been created and published.', $message_args),
        [1, 0] => t('@type %title has been published.', $message_args),
        [0, 1] => t('@type %title has been unpublished.', $message_args),
        default => t('@type %title has been updated.', $message_args),
      };

      // Show a button to copy the link when the document is published.
      if (!empty($statuses[0])) {
        // Create the message with copy link button.
        $entity_url = $entity->toUrl('canonical', [
          'absolute' => TRUE,
          'alias' => TRUE,
        ])->toString();

        $message_markup = [
          '#type' => 'container',
          '#attributes' => ['class' => ['status-message-with-button']],
          'message' => [
            '#markup' => $status_message,
          ],
          'copy_button' => [
            '#type' => 'button',
            '#value' => t('Copy link'),
            '#attributes' => [
              'class' => ['copy-link-button'],
              'data-copy-url' => $entity_url,
            ],
          ],
        ];

        $messages[$key] = \Drupal::service('renderer')->render($message_markup);
      }
      else {
        $messages[$key] = $status_message;
      }

      $found_update_message = TRUE;
      break;
    }
  }

  if ($found_update_message) {
    // Clear all status messages.
    $messenger->deleteByType('status');

    // Add the updated messages.
    foreach ($messages as $message) {
      $messenger->addStatus($message);
    }
  }
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_overview_vocabularies".
 */
function reliefweb_entities_form_taxonomy_overview_vocabularies_alter(array &$form, FormStateInterface $form_state) {
  // Prevent re-ordering the vocabularies without the appropriate permission.
  if (!\Drupal::currentUser()->hasPermission('administer taxonomy')) {
    $form['actions']['#access'] = FALSE;
    unset($form['vocabularies']['#tabledrag']);
    unset($form['vocabularies']['#header']['weight']);
    foreach (Element::children($form['vocabularies']) as $key) {
      unset($form['vocabularies'][$key]['weight']);
    }
  }
}

/**
 * Implements hook_form_HOOK_alter() for "taxonomy_overview_terms".
 */
function reliefweb_entities_form_taxonomy_overview_terms_alter(array &$form, FormStateInterface $form_state) {
  // Prevent re-ordering the terms without the appropriate permission.
  if (!\Drupal::currentUser()->hasPermission('administer taxonomy')) {
    $form['actions']['#access'] = FALSE;
    $form['help']['#access'] = FALSE;
    unset($form['terms']['#tabledrag']);
    unset($form['terms']['#header']['weight']);
    foreach (Element::children($form['terms']) as $key) {
      unset($form['terms'][$key]['weight']);
    }
  }
}

/**
 * Form entity builder callback.
 *
 * We emulate the logic to set the revision user and timestamp from
 * \Drupal\Core\Entity\ContentEntityForm::buildEntity() for taxonomy terms
 * because there is no easy way to have the taxonomy term entity type
 * `showRevisionUi()` method return TRUE...
 *
 * @param string $entity_type_id
 *   Entity type ID.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Term entity.
 * @param array $form
 *   The term form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function reliefweb_entities_term_form_entity_builder($entity_type_id, EntityInterface $entity, array &$form, FormStateInterface $form_state) {
  if ($entity instanceof RevisionLogInterface && !$form_state->isValueEmpty('revision')) {
    // Set the current user as the revision user if a new revision is requested.
    $entity->setRevisionUserId(\Drupal::currentUser()->id());
    $entity->setRevisionCreationTime(\Drupal::time()->getRequestTime());
  }
}

/**
 * Implements hook_form_alter().
 */
function reliefweb_entities_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  // Prevent deletion of taxonomy term referenced by other entities.
  $form_object = $form_state->getFormObject();
  if ($form_object instanceof EntityFormInterface && $form_object->getOperation() === 'delete') {
    $entity = $form_state->getFormObject()->getEntity();
    if (isset($entity) && $entity instanceof TermInterface && $entity->id() !== NULL) {
      if (TaxonomyHelper::isTermReferenced($entity)) {
        $form['actions']['submit']['#access'] = FALSE;
        $form['description']['#markup'] = t('The term CANNOT be deleted because there is content (reports, jobs, training etc.) tagged with it.');
      }
    }
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function reliefweb_entities_theme_registry_alter(array &$theme_registry) {
  // Remove the hook_preprocess_media() implementation from the media_library
  // because it's not compatible with the inline entity form as it tries to
  // create a link to the media while it may not yet have an ID (temporary
  // media entity when creating a new content). This is replaced by
  // reliefweb_entities_preprocess_media().
  //
  // @see media_library_preprocess_media()
  // @see reliefweb_entities_preprocess_media()
  foreach ($theme_registry as $theme => $info) {
    if (isset($info['preprocess functions'])) {
      foreach ($info['preprocess functions'] as $key => $value) {
        if ($value === 'media_library_preprocess_media') {
          unset($theme_registry[$theme]['preprocess functions'][$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_media().
 *
 * Replacement of media_library_preprocess_media() that is compatible with
 * inline_entity_form which can create temporary media which don't yet have
 * an ID and so cannot have a URL.
 *
 * @see media_library_preprocess_media()
 */
function reliefweb_entities_preprocess_media(array &$variables) {
  if ($variables['view_mode'] === 'media_library') {
    /** @var \Drupal\media\MediaInterface $media */
    $media = $variables['media'];
    $variables['#cache']['contexts'][] = 'user.permissions';
    if ($media->id() !== NULL) {
      $rel = $media->access('edit') ? 'edit-form' : 'canonical';
      $variables['url'] = $media->toUrl($rel, [
        'language' => $media->language(),
      ]);
    }
    $variables += [
      'preview_attributes' => new Attribute(),
      'metadata_attributes' => new Attribute(),
    ];
    $variables['status'] = $media->isPublished();
  }
}

/**
 * Implements hook_entity_presave().
 */
function reliefweb_entities_entity_presave(EntityInterface $entity) {
  // Remove control characters from an entity's text fields.
  reliefweb_entities_clean_text_fields($entity);

  // Set the taxonomy term revision.
  reliefweb_entities_set_taxonomy_term_revision($entity);
}

/**
 * Implements hook_ocha_content_classification_pre_entity_presave().
 *
 * Requeue entity for classification when changed.
 *
 * @todo handle other bundles than report.
 */
function reliefweb_entities_ocha_content_classification_pre_entity_presave(EntityInterface $entity): void {
  if (!\Drupal::currentUser()->hasPermission('requeue report for classification on change')) {
    return;
  }

  // This is restricted to reports for now to handle the "Document drop".
  // @see RW-1188
  if ($entity->bundle() !== 'report') {
    return;
  }

  if (!isset($entity->original)) {
    return;
  }

  // Check if the attachments have changed.
  // @todo we probably need to override the `equals` method in the
  // ReliefWebFileList to only check the UUIDs and hashes.
  if ($entity->field_file->equals($entity->original->field_file)) {
    return;
  }

  try {
    $content_entity_classifier = \Drupal::service('ocha_content_classification.content_entity_classifier');
  }
  catch (\Exception) {
    return;
  }

  /** @var \Drupal\ocha_content_classification\Entity\ClassificationWorkflowInterface $workflow */
  $workflow = $content_entity_classifier->getWorkflowForEntity($entity);
  if (empty($workflow)) {
    return;
  }

  // Delete any existing classification record so we can requeue the entity.
  $workflow->deleteClassificationProgress($entity);
}

/**
 * Implements hook_ocha_content_classification_post_entity_presave().
 *
 * Update the entity moderation status based on the classification status.
 */
function reliefweb_entities_ocha_content_classification_post_entity_presave(EntityInterface $entity): void {
  if (!($entity instanceof EntityModeratedInterface)) {
    return;
  }

  $account = match(TRUE) {
    $entity instanceof RevisionLogInterface => $entity->getRevisionUser(),
    $entity instanceof EntityOwnerInterface => $entity->getOwner(),
    default => $this->currentUser,
  };

  if ($account?->id() != 1 && $account?->hasPermission("adjust {$entity->bundle()} moderation status based on classification status")) {
    reliefweb_entities_adjust_moderation_status_based_on_classification_status($entity);
  }
}

/**
 * Adjust the entity moderation status based on the classification status.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 */
function reliefweb_entities_adjust_moderation_status_based_on_classification_status(EntityInterface $entity): void {
  if (!($entity instanceof EntityModeratedInterface)) {
    return;
  }

  // This flag is set when the classification failed or completed or when the
  // entity is going to be queued (or is already being queued) if the user who
  // triggered the entity saving was allowed to use the classification workflow.
  if (!isset($entity->ocha_content_classification_status)) {
    return;
  }

  $publication_protection_default_status = ReliefWebStateHelper::getPublicationPreventionDefaultModerationStatus(
    $entity->getEntityTypeId(),
    $entity->bundle(),
  );

  $status = match($entity->ocha_content_classification_status) {
    // Prevent publication if the document is queued for classification.
    // If the document is already in a non-published state then keep the current
    // status. This allows for example, to quickly mark a document as refused
    // or on-hold.
    ClassificationStatus::Queued => $entity->isPublishedModerationStatus() ? $publication_protection_default_status : $entity->getModerationStatus(),
    // Prevent publication if the document classification failed. A human should
    // review manually.
    ClassificationStatus::Failed => $entity->isPublishedModerationStatus() ? $publication_protection_default_status : $entity->getModerationStatus(),
    // For successful classification, we keep the current status.
    ClassificationStatus::Completed => $entity->getModerationStatus(),
    // This default case should not happen.
    default => $entity->getModerationStatus(),
  };

  if ($status !== $entity->getModerationStatus()) {
    $allowed_statuses = $entity->getAllowedModerationStatuses();
    // Ensure the new status is available otherwise default to draft or the
    // default moderation status for the entity. The point is to try to prevent
    // unsafe publication.
    $status = match(TRUE) {
      isset($allowed_statuses[$status]) => $status,
      isset($allowed_statuses['draft']) => 'draft',
      default => $entity->getDefaultModerationStatus(),
    };

    // Update the moderation status.
    $entity->setModerationStatus($status);
  }
}

/**
 * Implements hook_ocha_content_classification_force_field_update_alter().
 */
function reliefweb_entities_ocha_content_classification_classified_fields_alter(array &$fields, ClassificationWorkflowInterface $workflow, array $context) {
  // Get a list of fields to ignore.
  // @see RW-1189
  $key = 'reliefweb_ignore_classified_fields:' . $workflow->id();
  $ignore_fields = \Drupal::state()->get($key, []);
  $ignore_fields = array_flip($ignore_fields);
  foreach ($fields as $type => $field_list) {
    $fields[$type] = array_diff_key($field_list, $ignore_fields);
  }
}

/**
 * Implements hook_ocha_content_classification_prepare_entity_alter().
 */
function reliefweb_entities_ocha_content_classification_prepare_entity_alter(EntityInterface &$prepared_entity, ClassificationWorkflowInterface $workflow, array $context) {
  if ($prepared_entity->bundle() === 'report') {
    $classifier = $context['classifier'];
    if ($classifier->getPluginId() == 'inference') {
      $analyzable_fields = $classifier->getEnabledFields('analyzable');

      // Remove the body field if there are attachments to analyze.
      // The body may already be the result of a previous classification
      // attempt and currently we don't have a good way to know that at that
      // stage. For example if the entity was re-queued then the previous
      // classification record was deleted so we cannot retrieve the list of
      // fields that were classified.
      // @todo review if the classification progress is changed to keep the
      // history in which case we could check if the body was processed or not
      // by the classifier.
      if (!empty($analyzable_fields['field_file']['file']) && $prepared_entity->hasField('field_file') && !$prepared_entity->get('field_file')->isEmpty()) {
        $prepared_entity->set('body', NULL);
      }
    }
  }
}

/**
 * Set a taxonomy term's revision information.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 */
function reliefweb_entities_set_taxonomy_term_revision(EntityInterface $entity) {
  // Saving new revision of term on each save.
  if ($entity instanceof TermInterface) {
    $entity->setNewRevision(TRUE);
    if (is_null($entity->getRevisionUserId())) {
      $entity->setRevisionUserId(\Drupal::currentUser()->id());
    }
    if (empty($entity->getRevisionCreationTime())) {
      $entity->setRevisionCreationTime(\Drupal::time()->getRequestTime());
    }
  }
}

/**
 * Remove control characters from an entity's text fields.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 */
function reliefweb_entities_clean_text_fields(EntityInterface $entity) {
  $entity_type_id = $entity->getEntityTypeId();
  if ($entity_type_id === 'node' || $entity_type_id === 'taxonomy_term') {
    $field_definitions = \Drupal::service('entity_field.manager')
      ->getFieldDefinitions($entity_type_id, $entity->bundle());

    $text_field_types = [
      'text',
      'text_long',
      'text_with_summary',
      'string',
      'string_long',
    ];
    $columns = [
      'value',
      'summary',
    ];
    $options = [
      'title' => ['line_breaks' => TRUE, 'consecutive' => TRUE],
      'name' => ['line_breaks' => TRUE, 'consecutive' => TRUE],
    ];

    // Clean the text fields.
    foreach ($field_definitions as $field => $definition) {
      if ($entity->hasField($field) && in_array($definition->getType(), $text_field_types)) {
        foreach ($entity->get($field) as $item) {
          foreach ($columns as $column) {
            if (isset($item->{$column})) {
              $value = $item->get($column)->getValue();
              $item->set($column, TextHelper::cleanText($value, $options[$field] ?? []));
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_mail().
 *
 * Populate the subject and body of the message sent after publishing a report.
 */
function reliefweb_entities_mail($key, array &$message, array $parameters) {
  if ($key === 'report_publication_notification') {
    $message['subject'] = $parameters['subject'];
    $message['body'][] = $parameters['content'];
    // Plain text only.
    $message['params']['plaintext'] = MailHelper::getPlainText($message['body']);
    $message['params']['plain'] = TRUE;
    // Use the submit mailbox as sender and add it also as CC to track the
    // notifications.
    $submit = ReliefWebStateHelper::getSubmitEmail();
    if (!empty($submit)) {
      $message['headers']['From'] = $submit;
      $message['headers']['CC'] = $submit;
    }
  }
}

/**
 * Implements hook_cron().
 *
 * This performs the following tasks:
 * - Publish embargoed documents.
 * - Expire jobs and training.
 *
 * At max 20 nodes of each type is processed at once to avoid clogging the cron
 * process and using excessive resources.
 */
function reliefweb_entities_cron() {
  $storage = \Drupal::entityTypeManager()->getStorage('node');
  $cron_settings = \Drupal::config('reliefweb_entities.settings')->get('cron') ?? [];

  // Publish embargoed reports.
  $embargoed_ids = $storage
    ->getQuery()
    ->condition('type', 'report', '=')
    ->condition('moderation_status', 'embargoed', '=')
    ->condition('field_embargo_date.value', gmdate("Y-m-d\TH:i:s"), '<')
    ->range(0, $cron_settings['embargoed_reports_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  if (!empty($embargoed_ids)) {
    $reports = $storage->loadMultiple($embargoed_ids) ?? [];
    foreach ($reports as $report) {
      $timestamp = DateHelper::getDateTimeStamp($report->field_embargo_date->value);
      $report->setCreatedTime($timestamp);
      $report->setModerationStatus('published');
      $report->field_embargo_date->setValue([]);
      $report->setNewRevision(TRUE);
      $report->setRevisionUserId(2);
      $report->setRevisionCreationTime(time());
      $report->setRevisionLogMessage(strtr('Embargoed document automatically published on @date.', [
        '@date' => DateHelper::format($timestamp, 'custom', 'd M Y H:i e'),
      ]));
      $report->save();
    }
  }

  // Change status of expired jobs and training.
  $expired_ids = [];
  $time = gmmktime(0, 0, 0);
  $date = gmdate("Y-m-d", $time);

  $expired_ids += $storage
    ->getQuery()
    ->condition('type', 'job', '=')
    ->condition('moderation_status', 'published', '=')
    ->condition('field_job_closing_date.value', $date, '<')
    ->range(0, $cron_settings['expired_jobs_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  $expired_ids += $storage
    ->getQuery()
    ->condition('type', 'training', '=')
    ->condition('moderation_status', 'published', '=')
    ->condition('field_registration_deadline.value', $date, '<')
    ->range(0, $cron_settings['expired_training_limit'] ?? 20)
    ->accessCheck(FALSE)
    ->execute();

  if (!empty($expired_ids)) {
    $nodes = $storage->loadMultiple($expired_ids) ?? [];
    foreach ($nodes as $node) {
      $node->setModerationStatus('expired');
      $node->setNewRevision(TRUE);
      $node->setRevisionUserId(2);
      $node->setRevisionCreationTime(time());
      $node->setRevisionLogMessage(strtr('@type automatically expired on @date.', [
        '@type' => ucfirst($node->bundle()),
        '@date' => DateHelper::format($time, 'custom', 'd M Y H:i e'),
      ]));
      $node->save();
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function reliefweb_entities_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  // Open the clone entity form in a new tab.
  if (isset($data['tabs'][0]['content_entity_clone.clone']['#link'])) {
    $data['tabs'][0]['content_entity_clone.clone']['#link']['localized_options']['attributes']['target'] = '_blank';

    // Hide the report clone local task for submitters.
    // @todo remove if the granular permissions are added to the
    // content_entity_clone module.
    $current_user = \Drupal::currentUser();
    if ($current_user->hasRole('submitter') && !$current_user->hasRole('contributor') && !$current_user->hasRole('editor')) {
      $url = $data['tabs'][0]['content_entity_clone.clone']['#link']['url'] ?? NULL;
      if ($url instanceof Url) {
        $route_parameters = $url->getRouteParameters();
        if (isset($route_parameters['node_type']) && $route_parameters['node_type'] === 'report') {
          $data['tabs'][0]['content_entity_clone.clone']['#access'] = AccessResult::forbidden();
        }
      }
    }
  }

  // Add cache context for roles since the visibility depends on user roles.
  $cacheability->addCacheContexts(['user.roles']);
}

/**
 * Implements hook_preprocess_page__410().
 *
 * Add a user friendly message on inaccessible entity pages to indicate it's
 * no longer available (we assume the URL was previously accessible, which is
 * probably true in most cases).
 */
function reliefweb_entities_preprocess_page__410(array &$variables) {
  // @see \Drupal\reliefweb_entities\EventSubscriber\AccessDeniedToNotFound::on403().
  $exception = \Drupal::requestStack()->getCurrentRequest()->attributes->get('exception');
  if (isset($exception) && $exception instanceof GoneHttpException) {
    $variables['page']['content']['message'] = [
      '#type' => 'markup',
      '#markup' => $exception->getMessage(),
    ];
  }

  // We need to vary the cache whether or not we are on an entity page
  // otherwise visiting a non entity inaccessible page will cache the result
  // and this preprocess hook implementation will not be called when visiting
  // an inaccessible entity page afterwards.
  $variables['#cache']['contexts'][] = 'url.path';
}

/**
 * Implements hook_preprocess_page_title().
 */
function reliefweb_entities_4xx_title() {
  $exception = \Drupal::requestStack()->getCurrentRequest()->attributes->get('exception');
  if (isset($exception) && $exception instanceof GoneHttpException) {
    return t('Gone');
  }
  return 'Client error';
}

/**
 * Implements hook_ENTITY_TYPE_delete() for 'media'.
 *
 * Remove the source file when deleting a media.
 */
function reliefweb_entities_media_delete(MediaInterface $media) {
  $file = MediaHelper::getMediaSourceFile($media);
  // Delete the source file if not used anywhere else.
  if (!empty($file) && empty(\Drupal::service('file.usage')->listUsage($file))) {
    $file->setTemporary();
    $file->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for 'node'.
 *
 * Retrieve the list of referenced media Ids across all revisions before
 * deleting the entity.
 */
function reliefweb_entities_node_predelete(EntityInterface $entity) {
  // Only the image field for announcements and reports do not allow re-using
  // existing media.
  if (in_array($entity->bundle(), ['announcement', 'report'])) {
    // Get the list of referenced media Ids. We need to do that before the
    // entity is actually deleted.
    $entity->_referencedMediaIds = \Drupal::database()
      ->select('node_revision__field_image', 'f')
      ->fields('f', ['field_image_target_id'])
      ->condition('f.entity_id', $entity->id(), '=')
      ->distinct()
      ->execute()
      ?->fetchCol() ?? [];
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 *
 * Remove referenced media that are not used anymore.
 */
function reliefweb_entities_node_delete(EntityInterface $entity) {
  // Only the image field for announcements and reports do not allow re-using
  // existing media.
  if (in_array($entity->bundle(), ['announcement', 'report'])) {
    // Delete referenced media entities.
    if (!empty($entity->_referencedMediaIds)) {
      $media_entities = \Drupal::entityTypeManager()
        ->getStorage('media')
        ->loadMultiple($entity->_referencedMediaIds);

      foreach ($media_entities as $media) {
        $media->delete();
      }
    }
  }
}
